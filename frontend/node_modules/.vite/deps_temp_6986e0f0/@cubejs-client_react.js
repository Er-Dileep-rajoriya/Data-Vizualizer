import {
  require_react
} from "./chunk-KZA2ZXKF.js";
import {
  ResultSet,
  areQueriesEqual,
  clone_default,
  defaultHeuristics,
  defaultOrder,
  equals_default,
  flattenFilters,
  fromPairs_default,
  getQueryMembers,
  indexBy_default,
  isQueryPresent,
  moveItemInArray,
  movePivotItem,
  pick_default,
  prop_default,
  removeEmptyQueryFields,
  toPairs_default,
  uniqBy_default,
  uniq_default,
  validateQuery
} from "./chunk-4ZSOVTTX.js";
import {
  __publicField,
  __toESM
} from "./chunk-LNEMQRCO.js";

// node_modules/@cubejs-client/react/dist/cubejs-client-react.esm.js
var import_react = __toESM(require_react());
var CubeContext = (0, import_react.createContext)(null);
var QueryRenderer = class extends import_react.default.Component {
  // @deprecated use `isQueryPresent` from `@cubejs-client/core`
  static isQueryPresent(query) {
    return isQueryPresent(query);
  }
  constructor(props) {
    super(props);
    this.state = {};
    this.mutexObj = {};
  }
  componentDidMount() {
    const {
      query,
      queries
    } = this.props;
    if (query) {
      this.load(query);
    }
    if (queries) {
      this.loadQueries(queries);
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    const {
      query,
      queries,
      render,
      cubeApi,
      loadSql,
      updateOnlyOnStateChange
    } = this.props;
    if (!updateOnlyOnStateChange) {
      return true;
    }
    return !equals_default(nextProps.query, query) || !equals_default(nextProps.queries, queries) || (nextProps.render == null || render == null) && nextProps.render !== render || nextProps.cubeApi !== cubeApi || nextProps.loadSql !== loadSql || !equals_default(nextState, this.state) || nextProps.updateOnlyOnStateChange !== updateOnlyOnStateChange;
  }
  componentDidUpdate(prevProps) {
    const {
      query,
      queries
    } = this.props;
    if (!equals_default(prevProps.query, query)) {
      this.load(query);
    }
    if (!equals_default(prevProps.queries, queries)) {
      this.loadQueries(queries);
    }
  }
  cubeApi() {
    return this.props.cubeApi || this.context && this.context.cubeApi;
  }
  load(query) {
    const {
      resetResultSetOnChange
    } = this.props;
    this.setState({
      isLoading: true,
      error: null,
      sqlQuery: null,
      ...resetResultSetOnChange ? {
        resultSet: null
      } : {}
    });
    const {
      loadSql
    } = this.props;
    const cubeApi = this.cubeApi();
    if (query && isQueryPresent(query)) {
      if (loadSql === "only") {
        cubeApi.sql(query, {
          mutexObj: this.mutexObj,
          mutexKey: "sql"
        }).then((sqlQuery) => this.setState({
          sqlQuery,
          error: null,
          isLoading: false
        })).catch((error) => this.setState({
          ...resetResultSetOnChange ? {
            resultSet: null
          } : {},
          error,
          isLoading: false
        }));
      } else if (loadSql) {
        Promise.all([cubeApi.sql(query, {
          mutexObj: this.mutexObj,
          mutexKey: "sql"
        }), cubeApi.load(query, {
          mutexObj: this.mutexObj,
          mutexKey: "query"
        })]).then(([sqlQuery, resultSet]) => this.setState({
          sqlQuery,
          resultSet,
          error: null,
          isLoading: false
        })).catch((error) => this.setState({
          ...resetResultSetOnChange ? {
            resultSet: null
          } : {},
          error,
          isLoading: false
        }));
      } else {
        cubeApi.load(query, {
          mutexObj: this.mutexObj,
          mutexKey: "query"
        }).then((resultSet) => this.setState({
          resultSet,
          error: null,
          isLoading: false
        })).catch((error) => this.setState({
          ...resetResultSetOnChange ? {
            resultSet: null
          } : {},
          error,
          isLoading: false
        }));
      }
    }
  }
  loadQueries(queries) {
    const cubeApi = this.cubeApi();
    const {
      resetResultSetOnChange
    } = this.props;
    this.setState({
      isLoading: true,
      ...resetResultSetOnChange ? {
        resultSet: null
      } : {},
      error: null
    });
    const resultPromises = Promise.all(toPairs_default(queries).map(([name, query]) => cubeApi.load(query, {
      mutexObj: this.mutexObj,
      mutexKey: name
    }).then((r) => [name, r])));
    resultPromises.then((resultSet) => this.setState({
      resultSet: fromPairs_default(resultSet),
      error: null,
      isLoading: false
    })).catch((error) => this.setState({
      ...resetResultSetOnChange ? {
        resultSet: null
      } : {},
      error,
      isLoading: false
    }));
  }
  render() {
    var _a;
    const {
      error,
      queries,
      resultSet,
      isLoading,
      sqlQuery
    } = this.state;
    const {
      render
    } = this.props;
    const loadState = {
      error: error ? new Error(((_a = error.response) == null ? void 0 : _a.plainError) || error.message || error.toString()) : null,
      resultSet: queries ? resultSet || {} : resultSet,
      loadingState: {
        isLoading
      },
      sqlQuery
    };
    if (render) {
      return render(loadState);
    }
    return null;
  }
};
__publicField(QueryRenderer, "contextType", CubeContext);
__publicField(QueryRenderer, "defaultProps", {
  cubeApi: null,
  query: null,
  render: null,
  queries: null,
  loadSql: null,
  updateOnlyOnStateChange: false,
  resetResultSetOnChange: true
});
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var QueryRendererWithTotals = ({
  query,
  ...restProps
}) => import_react.default.createElement(QueryRenderer, _extends({
  queries: {
    totals: {
      ...query,
      dimensions: [],
      timeDimensions: query.timeDimensions ? query.timeDimensions.map((td) => ({
        ...td,
        granularity: null
      })) : void 0
    },
    main: query
  }
}, restProps));
function removeEmpty(obj) {
  if (typeof obj !== "object") {
    return obj;
  }
  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v != null).map(([k, v]) => {
    if (Array.isArray(v)) {
      return [k, v.map(removeEmpty)];
    }
    return [k, typeof v === "object" ? removeEmpty(v) : v];
  }));
}
var granularities = [{
  name: void 0,
  title: "w/o grouping"
}, {
  name: "second",
  title: "Second"
}, {
  name: "minute",
  title: "Minute"
}, {
  name: "hour",
  title: "Hour"
}, {
  name: "day",
  title: "Day"
}, {
  name: "week",
  title: "Week"
}, {
  name: "month",
  title: "Month"
}, {
  name: "quarter",
  title: "Quarter"
}, {
  name: "year",
  title: "Year"
}];
var _QueryBuilder = class _QueryBuilder extends import_react.default.Component {
  constructor(props) {
    super(props);
    __publicField(this, "fetchMeta", async () => {
      var _a, _b, _c;
      if (!this.cubeApi()) {
        return;
      }
      let meta;
      let metaError = null;
      let richMetaError = null;
      let metaErrorStack = null;
      try {
        this.setState({
          isFetchingMeta: true
        });
        meta = await this.cubeApi().meta();
      } catch (error) {
        metaError = ((_a = error.response) == null ? void 0 : _a.plainError) || error;
        richMetaError = error;
        metaErrorStack = ((_c = (_b = error.response) == null ? void 0 : _b.stack) == null ? void 0 : _c.replace(error.message || "", "")) || "";
      }
      this.setState({
        meta,
        metaError: metaError ? new Error(metaError.message || metaError.toString()) : null,
        richMetaError,
        metaErrorStack,
        isFetchingMeta: false
      }, () => {
        this.updateQuery({});
      });
    });
    this.state = {
      query: props.defaultQuery || props.query,
      chartType: props.defaultChartType,
      validatedQuery: props.query,
      // deprecated, validatedQuery should not be set until after dry-run for safety
      missingMembers: [],
      // todo: rename to `isMetaReady`
      isFetchingMeta: true,
      dryRunResponse: null,
      ...props.vizState,
      // deprecated
      ...props.initialVizState
    };
    this.mutexObj = {};
    this.orderMembersOrderKeys = [];
  }
  // This is an anti-pattern, only kept for backward compatibility
  // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state
  static getDerivedStateFromProps(props, state) {
    if (props.query || props.vizState) {
      const nextState = {
        ...state,
        ...props.vizState || {}
      };
      if (Array.isArray(props.query)) {
        throw new Error("Array of queries is not supported.");
      }
      return {
        ...nextState,
        query: {
          ...nextState.query,
          ...props.query || {}
        }
      };
    }
    return null;
  }
  static resolveMember(type, {
    meta,
    query
  }) {
    if (!meta) {
      return [];
    }
    if (Array.isArray(query)) {
      return query.reduce((memo, currentQuery) => memo.concat(_QueryBuilder.resolveMember(type, {
        meta,
        query: currentQuery
      })), []);
    }
    if (type === "timeDimensions") {
      return (query.timeDimensions || []).map((m, index) => ({
        ...m,
        dimension: {
          ...meta.resolveMember(m.dimension, "dimensions"),
          granularities
        },
        index
      }));
    }
    return (query[type] || []).map((m, index) => ({
      index,
      ...meta.resolveMember(m, type)
    }));
  }
  async componentDidMount() {
    this.prevContext = this.context;
    await this.fetchMeta();
  }
  async componentDidUpdate(prevProps) {
    var _a, _b;
    const {
      schemaVersion,
      onSchemaChange
    } = this.props;
    const {
      meta
    } = this.state;
    if (((_a = this.prevContext) == null ? void 0 : _a.cubeApi) !== ((_b = this.context) == null ? void 0 : _b.cubeApi)) {
      this.prevContext = this.context;
      await this.fetchMeta();
    }
    if (prevProps.schemaVersion !== schemaVersion) {
      try {
        const newMeta = await this.cubeApi().meta();
        if (!equals_default(newMeta, meta) && typeof onSchemaChange === "function") {
          onSchemaChange({
            schemaVersion,
            refresh: async () => {
              await this.fetchMeta();
            }
          });
        }
      } catch (error) {
        this.setState({
          metaError: error
        });
      }
    }
  }
  cubeApi() {
    const {
      cubeApi
    } = this.props;
    return cubeApi || this.context && this.context.cubeApi;
  }
  getMissingMembers(query, meta) {
    if (!meta) {
      return [];
    }
    return getQueryMembers(query).map((member) => {
      const resolvedMember = meta.resolveMember(member, ["measures", "dimensions", "segments"]);
      if (resolvedMember.error) {
        return member;
      }
      return false;
    }).filter(Boolean);
  }
  isQueryPresent() {
    const {
      query
    } = this.state;
    return QueryRenderer.isQueryPresent(query);
  }
  prepareRenderProps(queryRendererProps) {
    const getName = (member) => member.name;
    const toTimeDimension = (member) => {
      const rangeSelection = member.compareDateRange ? {
        compareDateRange: member.compareDateRange
      } : {
        dateRange: member.dateRange
      };
      return removeEmpty({
        dimension: member.dimension.name,
        granularity: member.granularity,
        ...rangeSelection
      });
    };
    const toFilter = (member) => {
      var _a, _b;
      return {
        member: ((_a = member.member) == null ? void 0 : _a.name) || ((_b = member.dimension) == null ? void 0 : _b.name),
        operator: member.operator,
        ...["set", "notSet"].includes(member.operator) ? {} : {
          values: member.values
        }
      };
    };
    const updateMethods = (memberType, toQuery = getName) => ({
      add: (member) => {
        const {
          query: query2
        } = this.state;
        this.updateQuery({
          [memberType]: (query2[memberType] || []).concat(toQuery(member))
        });
      },
      remove: (member) => {
        const {
          query: query2
        } = this.state;
        return this.updateQuery({
          [memberType]: (query2[memberType] || []).filter((_, index) => index !== member.index)
        });
      },
      update: (member, updateWith) => {
        const {
          query: query2
        } = this.state;
        const members2 = (query2[memberType] || []).concat([]);
        members2.splice(member.index, 1, toQuery(updateWith));
        return this.updateQuery({
          [memberType]: members2
        });
      }
    });
    const {
      meta,
      metaError,
      richMetaError,
      query,
      queryError,
      chartType,
      pivotConfig,
      validatedQuery,
      missingMembers,
      isFetchingMeta,
      dryRunResponse,
      metaErrorStack
    } = this.state;
    const flatFilters = uniqBy_default((filter) => `${prop_default("member", filter)}${prop_default("operator", filter)}`, flattenFilters(meta && query.filters || []).map((filter) => ({
      ...filter,
      member: filter.member || filter.dimension
    })));
    const filters = flatFilters.map((m, i) => ({
      ...m,
      dimension: meta.resolveMember(m.member || m.dimension, ["dimensions", "measures"]),
      operators: meta.filterOperatorsForMember(m.member || m.dimension, ["dimensions", "measures"]),
      index: i
    }));
    const measures = _QueryBuilder.resolveMember("measures", this.state);
    const dimensions = _QueryBuilder.resolveMember("dimensions", this.state);
    const timeDimensions = _QueryBuilder.resolveMember("timeDimensions", this.state);
    const segments = (meta && query.segments || []).map((m, i) => ({
      index: i,
      ...meta.resolveMember(m, "segments")
    }));
    let availableMeasures = [];
    let availableDimensions = [];
    let availableSegments = [];
    let availableFilterMembers = [];
    const availableMembers = (meta == null ? void 0 : meta.membersGroupedByCube()) || {
      measures: [],
      dimensions: [],
      segments: [],
      timeDimensions: []
    };
    if (meta) {
      availableMeasures = meta.membersForQuery(query, "measures");
      availableDimensions = meta.membersForQuery(query, "dimensions");
      availableSegments = meta.membersForQuery(query, "segments");
      const indexedMeasures = indexBy_default(prop_default("cubeName"), availableMembers.measures);
      const indexedDimensions = indexBy_default(prop_default("cubeName"), availableMembers.dimensions);
      const cubeNames = uniq_default([...Object.keys(indexedMeasures), ...Object.keys(indexedDimensions)]).sort();
      availableFilterMembers = cubeNames.map((name) => {
        var _a, _b;
        const cube = indexedMeasures[name] || indexedDimensions[name];
        return {
          ...cube,
          members: [...(_a = indexedMeasures[name]) == null ? void 0 : _a.members, ...(_b = indexedDimensions[name]) == null ? void 0 : _b.members].sort((a, b) => a.shortTitle > b.shortTitle ? 1 : -1)
        };
      });
    }
    const activeOrder = Array.isArray(query.order) ? Object.fromEntries(query.order) : query.order;
    const members = [...measures, ...dimensions, ...timeDimensions.map(({
      dimension
    }) => dimension)];
    let orderMembers = uniqBy_default(prop_default("id"), [
      // uniqBy prefers first, so these will only be added if not already in the query
      ...members.map(({
        name,
        title
      }) => ({
        id: name,
        title,
        order: (activeOrder == null ? void 0 : activeOrder[name]) || "none"
      }))
    ]);
    if (this.orderMembersOrderKeys.length !== orderMembers.length) {
      this.orderMembersOrderKeys = orderMembers.map(({
        id
      }) => id);
    }
    if (this.orderMembersOrderKeys.length) {
      orderMembers = (this.orderMembersOrderKeys || []).map((id) => orderMembers.find((member) => member.id === id)).filter(Boolean);
    }
    return {
      meta,
      metaError,
      richMetaError,
      metaErrorStack,
      query,
      error: queryError,
      // Match same name as QueryRenderer prop
      validatedQuery,
      isQueryPresent: this.isQueryPresent(),
      chartType,
      measures,
      dimensions,
      timeDimensions,
      segments,
      filters,
      orderMembers,
      availableMeasures,
      availableDimensions,
      availableTimeDimensions: availableDimensions.filter((m) => m.type === "time"),
      availableSegments,
      availableMembers,
      availableFilterMembers,
      updateQuery: (queryUpdate) => this.updateQuery(queryUpdate),
      updateMeasures: updateMethods("measures"),
      updateDimensions: updateMethods("dimensions"),
      updateSegments: updateMethods("segments"),
      updateTimeDimensions: updateMethods("timeDimensions", toTimeDimension),
      updateFilters: updateMethods("filters", toFilter),
      updateChartType: (newChartType) => this.updateVizState({
        chartType: newChartType
      }),
      updateOrder: {
        set: (memberId, newOrder = "asc") => {
          this.updateQuery({
            order: orderMembers.map((orderMember) => ({
              ...orderMember,
              order: orderMember.id === memberId ? newOrder : orderMember.order
            })).reduce((acc, {
              id,
              order
            }) => order !== "none" ? [...acc, [id, order]] : acc, [])
          });
        },
        update: (order) => {
          this.updateQuery({
            order
          });
        },
        reorder: (sourceIndex, destinationIndex) => {
          if (sourceIndex == null || destinationIndex == null) {
            return;
          }
          const nextArray = moveItemInArray(orderMembers, sourceIndex, destinationIndex);
          this.orderMembersOrderKeys = nextArray.map(({
            id
          }) => id);
          this.updateQuery({
            order: nextArray.reduce((acc, {
              id,
              order
            }) => order !== "none" ? [...acc, [id, order]] : acc, [])
          });
        }
      },
      pivotConfig,
      updatePivotConfig: {
        moveItem: ({
          sourceIndex,
          destinationIndex,
          sourceAxis,
          destinationAxis
        }) => {
          this.updateVizState({
            pivotConfig: movePivotItem(pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis)
          });
        },
        update: (config) => {
          const {
            limit
          } = config;
          this.updateVizState({
            pivotConfig: {
              ...pivotConfig,
              ...config
            },
            ...limit ? {
              query: {
                ...query,
                limit
              }
            } : null
          });
        }
      },
      missingMembers,
      refresh: this.fetchMeta,
      isFetchingMeta,
      dryRunResponse,
      ...queryRendererProps
    };
  }
  updateQuery(queryUpdate) {
    const {
      query
    } = this.state;
    this.updateVizState({
      query: removeEmptyQueryFields({
        ...query,
        ...queryUpdate
      })
    });
  }
  async updateVizState(state) {
    var _a;
    const {
      setQuery,
      setVizState
    } = this.props;
    const {
      query: stateQuery,
      pivotConfig: statePivotConfig,
      chartType,
      meta
    } = this.state;
    const finalState = this.applyStateChangeHeuristics(state);
    if (!finalState.query) {
      finalState.query = {
        ...stateQuery
      };
    }
    let vizStateSent = null;
    const handleVizStateChange = (currentState) => {
      const {
        onVizStateChanged
      } = this.props;
      if (onVizStateChanged) {
        const newVizState = pick_default(["chartType", "pivotConfig", "query"], currentState);
        if (!vizStateSent || !equals_default(vizStateSent, newVizState)) {
          onVizStateChanged(newVizState);
          vizStateSent = clone_default(newVizState);
        }
      }
    };
    const runSetters = (currentState) => {
      if (setVizState) {
        setVizState(pick_default(["chartType", "pivotConfig", "query"], currentState));
      }
      if (currentState.query && setQuery) {
        setQuery(currentState.query);
      }
    };
    if (finalState.shouldApplyHeuristicOrder) {
      finalState.query.order = defaultOrder(finalState.query);
    }
    finalState.pivotConfig = ResultSet.getNormalizedPivotConfig(finalState.query, finalState.pivotConfig !== void 0 ? finalState.pivotConfig : statePivotConfig);
    finalState.missingMembers = this.getMissingMembers(finalState.query, meta);
    finalState.chartType = finalState.chartType || state.chartType || chartType;
    runSetters({
      ...state,
      query: finalState.query
    });
    this.setState({
      ...finalState,
      queryError: null
    });
    handleVizStateChange(finalState);
    const shouldFetchDryRun = !equals_default(pick_default(["measures", "dimensions", "timeDimensions"], stateQuery), pick_default(["measures", "dimensions", "timeDimensions"], finalState.query));
    if (shouldFetchDryRun && isQueryPresent(finalState.query) && finalState.missingMembers.length === 0) {
      try {
        const response = await this.cubeApi().dryRun(finalState.query, {
          mutexObj: this.mutexObj
        });
        if (finalState.shouldApplyHeuristicOrder) {
          finalState.query.order = (response.queryOrder || []).reduce((memo, current) => ({
            ...memo,
            ...current
          }), {});
        }
        finalState.pivotConfig = ResultSet.getNormalizedPivotConfig(response.pivotQuery, finalState.pivotConfig);
        finalState.validatedQuery = this.validatedQuery(finalState);
        finalState.dryRunResponse = response;
        if (isQueryPresent(stateQuery)) {
          runSetters({
            ...this.state,
            ...finalState
          });
        }
      } catch (error) {
        this.setState({
          queryError: new Error(((_a = error.response) == null ? void 0 : _a.plainError) || error.message),
          richQueryError: new Error(error.message || error.toString())
        });
      }
    }
    this.setState(finalState, () => handleVizStateChange(this.state));
  }
  validatedQuery(state) {
    const {
      query
    } = state || this.state;
    return validateQuery(query);
  }
  defaultHeuristics(newState) {
    const {
      query,
      sessionGranularity,
      meta
    } = this.state;
    return defaultHeuristics(newState, query, {
      meta,
      sessionGranularity: sessionGranularity || "day"
    });
  }
  applyStateChangeHeuristics(newState) {
    const {
      stateChangeHeuristics,
      disableHeuristics
    } = this.props;
    if (disableHeuristics) {
      return newState;
    }
    return stateChangeHeuristics && stateChangeHeuristics(this.state, newState) || this.defaultHeuristics(newState);
  }
  render() {
    const {
      query
    } = this.state;
    const {
      cubeApi,
      render,
      wrapWithQueryRenderer
    } = this.props;
    if (wrapWithQueryRenderer) {
      return import_react.default.createElement(QueryRenderer, {
        query,
        cubeApi,
        resetResultSetOnChange: false,
        render: (queryRendererProps) => {
          if (render) {
            return render(this.prepareRenderProps(queryRendererProps));
          }
          return null;
        }
      });
    } else {
      if (render) {
        return render(this.prepareRenderProps());
      }
      return null;
    }
  }
};
__publicField(_QueryBuilder, "contextType", CubeContext);
__publicField(_QueryBuilder, "defaultProps", {
  cubeApi: null,
  stateChangeHeuristics: null,
  disableHeuristics: false,
  render: null,
  wrapWithQueryRenderer: true,
  defaultChartType: "line",
  defaultQuery: {},
  initialVizState: null,
  onVizStateChanged: null,
  // deprecated
  query: null,
  setQuery: null,
  vizState: null,
  setVizState: null
});
var QueryBuilder = _QueryBuilder;
function CubeProvider({
  cubeApi,
  children,
  options = {}
}) {
  return import_react.default.createElement(CubeContext.Provider, {
    value: {
      cubeApi,
      options
    }
  }, children);
}
function useDeepCompareMemoize(value) {
  const ref = (0, import_react.useRef)([]);
  if (!equals_default(value, ref.current)) {
    ref.current = value;
  }
  return ref.current;
}
function useIsMounted() {
  const isMounted = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return () => isMounted.current;
}
function useCubeFetch(method, options = {}) {
  var _a;
  const isMounted = useIsMounted();
  const context = (0, import_react.useContext)(CubeContext);
  const mutexRef = (0, import_react.useRef)({});
  const [response, setResponse] = (0, import_react.useState)({
    isLoading: false,
    response: null
  });
  const [error, setError] = (0, import_react.useState)(null);
  const {
    skip = false
  } = options;
  async function load(loadOptions = {}, ignoreSkip = false) {
    const cubeApi = options.cubeApi || (context == null ? void 0 : context.cubeApi);
    const query = loadOptions.query || options.query;
    const queryCondition = method === "meta" ? true : query && isQueryPresent(query);
    if (cubeApi && (ignoreSkip || !skip) && queryCondition) {
      setError(null);
      setResponse({
        isLoading: true,
        response: null
      });
      const coreOptions = {
        mutexObj: mutexRef.current,
        mutexKey: method
      };
      const args = method === "meta" ? [coreOptions] : [query, coreOptions];
      try {
        const response2 = await cubeApi[method](...args);
        if (isMounted()) {
          setResponse({
            response: response2,
            isLoading: false
          });
        }
      } catch (error2) {
        if (isMounted()) {
          setError(error2);
          setResponse({
            isLoading: false,
            response: null
          });
        }
      }
    }
  }
  (0, import_react.useEffect)(() => {
    load();
  }, useDeepCompareMemoize([Object.keys(((_a = options.query) == null ? void 0 : _a.order) || {}), options, context]));
  return {
    ...response,
    error,
    refetch: (options2) => load(options2, true)
  };
}
function useCubeSql(query, options = {}) {
  return useCubeFetch("sql", {
    ...options,
    query
  });
}
function useDryRun(query, options = {}) {
  return useCubeFetch("dryRun", {
    ...options,
    query
  });
}
function useLazyDryRun(query, options = {}) {
  const {
    refetch,
    ...result
  } = useCubeFetch("dryRun", {
    ...options,
    query,
    skip: true
  });
  return [refetch, result];
}
function useCubeQuery(query, options = {}) {
  const mutexRef = (0, import_react.useRef)({});
  const isMounted = useIsMounted();
  const [currentQuery, setCurrentQuery] = (0, import_react.useState)(null);
  const [isLoading, setLoading] = (0, import_react.useState)(false);
  const [resultSet, setResultSet] = (0, import_react.useState)(null);
  const [progress, setProgress] = (0, import_react.useState)(null);
  const [error, setError] = (0, import_react.useState)(null);
  const context = (0, import_react.useContext)(CubeContext);
  let subscribeRequest = null;
  const progressCallback = ({
    progressResponse
  }) => setProgress(progressResponse);
  async function fetch() {
    var _a;
    const {
      resetResultSetOnChange
    } = options;
    const cubeApi = options.cubeApi || (context == null ? void 0 : context.cubeApi);
    if (!cubeApi) {
      throw new Error("Cube API client is not provided");
    }
    if (resetResultSetOnChange) {
      setResultSet(null);
    }
    setError(null);
    setLoading(true);
    try {
      const response = await cubeApi.load(query, {
        mutexObj: mutexRef.current,
        mutexKey: "query",
        progressCallback,
        castNumerics: Boolean(typeof options.castNumerics === "boolean" ? options.castNumerics : (_a = context == null ? void 0 : context.options) == null ? void 0 : _a.castNumerics)
      });
      if (isMounted()) {
        setResultSet(response);
        setProgress(null);
      }
    } catch (error2) {
      if (isMounted()) {
        setError(error2);
        setResultSet(null);
        setProgress(null);
      }
    }
    if (isMounted()) {
      setLoading(false);
    }
  }
  (0, import_react.useEffect)(() => {
    const {
      skip = false,
      resetResultSetOnChange
    } = options;
    const cubeApi = options.cubeApi || (context == null ? void 0 : context.cubeApi);
    if (!cubeApi) {
      throw new Error("Cube API client is not provided");
    }
    async function loadQuery() {
      if (!skip && isQueryPresent(query)) {
        if (!areQueriesEqual(currentQuery, query)) {
          if (resetResultSetOnChange == null || resetResultSetOnChange) {
            setResultSet(null);
          }
          setCurrentQuery(query);
        }
        setError(null);
        setLoading(true);
        try {
          if (subscribeRequest) {
            await subscribeRequest.unsubscribe();
            subscribeRequest = null;
          }
          if (options.subscribe) {
            subscribeRequest = cubeApi.subscribe(query, {
              mutexObj: mutexRef.current,
              mutexKey: "query",
              progressCallback
            }, (e, result) => {
              if (isMounted()) {
                if (e) {
                  setError(e);
                } else {
                  setResultSet(result);
                }
                setLoading(false);
                setProgress(null);
              }
            });
          } else {
            await fetch();
          }
        } catch (e) {
          if (isMounted()) {
            setError(e);
            setResultSet(null);
            setLoading(false);
            setProgress(null);
          }
        }
      }
    }
    loadQuery();
    return () => {
      if (subscribeRequest) {
        subscribeRequest.unsubscribe();
        subscribeRequest = null;
      }
    };
  }, useDeepCompareMemoize([query, Object.keys(query && query.order || {}), options, context]));
  return {
    isLoading,
    resultSet,
    error,
    progress,
    previousQuery: currentQuery,
    refetch: fetch
  };
}
function useCubeMeta(options = {}) {
  return useCubeFetch("meta", options);
}
export {
  CubeContext,
  CubeProvider,
  QueryBuilder,
  QueryRenderer,
  QueryRendererWithTotals,
  useCubeMeta,
  useCubeQuery,
  useCubeSql,
  useDryRun,
  useLazyDryRun
};
//# sourceMappingURL=@cubejs-client_react.js.map
