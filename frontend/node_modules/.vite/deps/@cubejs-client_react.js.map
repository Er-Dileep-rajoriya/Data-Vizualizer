{
  "version": 3,
  "sources": ["../../@cubejs-client/react/src/CubeContext.js", "../../@cubejs-client/react/src/QueryRenderer.jsx", "../../@cubejs-client/react/src/QueryRendererWithTotals.jsx", "../../@cubejs-client/react/src/utils.js", "../../@cubejs-client/react/src/QueryBuilder.jsx", "../../@cubejs-client/react/src/CubeProvider.jsx", "../../@cubejs-client/react/src/hooks/deep-compare-memoize.js", "../../@cubejs-client/react/src/hooks/is-mounted.js", "../../@cubejs-client/react/src/hooks/cube-fetch.js", "../../@cubejs-client/react/src/hooks/cube-sql.js", "../../@cubejs-client/react/src/hooks/dry-run.js", "../../@cubejs-client/react/src/hooks/lazy-dry-run.js", "../../@cubejs-client/react/src/hooks/cube-query.js", "../../@cubejs-client/react/src/hooks/cube-meta.js"],
  "sourcesContent": ["import { createContext } from 'react';\n\nexport default createContext(null);\n", "import React from 'react';\nimport { equals, toPairs, fromPairs } from 'ramda';\nimport { isQueryPresent } from '@cubejs-client/core';\n\nimport CubeContext from './CubeContext';\n\nexport default class QueryRenderer extends React.Component {\n  static contextType = CubeContext;\n\n  static defaultProps = {\n    cubeApi: null,\n    query: null,\n    render: null,\n    queries: null,\n    loadSql: null,\n    updateOnlyOnStateChange: false,\n    resetResultSetOnChange: true\n  };\n\n  // @deprecated use `isQueryPresent` from `@cubejs-client/core`\n  static isQueryPresent(query) {\n    return isQueryPresent(query);\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.mutexObj = {};\n  }\n\n  componentDidMount() {\n    const { query, queries } = this.props;\n    if (query) {\n      this.load(query);\n    }\n    if (queries) {\n      this.loadQueries(queries);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {\n      query, queries, render, cubeApi, loadSql, updateOnlyOnStateChange\n    } = this.props;\n    if (!updateOnlyOnStateChange) {\n      return true;\n    }\n    return !equals(nextProps.query, query)\n      || !equals(nextProps.queries, queries)\n      || ((nextProps.render == null || render == null) && nextProps.render !== render)\n      || nextProps.cubeApi !== cubeApi\n      || nextProps.loadSql !== loadSql\n      || !equals(nextState, this.state)\n      || nextProps.updateOnlyOnStateChange !== updateOnlyOnStateChange;\n  }\n\n  componentDidUpdate(prevProps) {\n    const { query, queries } = this.props;\n    if (!equals(prevProps.query, query)) {\n      this.load(query);\n    }\n\n    if (!equals(prevProps.queries, queries)) {\n      this.loadQueries(queries);\n    }\n  }\n\n  cubeApi() {\n    // eslint-disable-next-line react/destructuring-assignment\n    return this.props.cubeApi || this.context && this.context.cubeApi;\n  }\n\n  load(query) {\n    const { resetResultSetOnChange } = this.props;\n    this.setState({\n      isLoading: true,\n      error: null,\n      sqlQuery: null,\n      ...(resetResultSetOnChange ? { resultSet: null } : {})\n    });\n    const { loadSql } = this.props;\n    const cubeApi = this.cubeApi();\n\n    if (query && isQueryPresent(query)) {\n      if (loadSql === 'only') {\n        cubeApi.sql(query, { mutexObj: this.mutexObj, mutexKey: 'sql' })\n          .then(sqlQuery => this.setState({ sqlQuery, error: null, isLoading: false }))\n          .catch(error => this.setState({\n            ...(resetResultSetOnChange ? { resultSet: null } : {}),\n            error,\n            isLoading: false\n          }));\n      } else if (loadSql) {\n        Promise.all([\n          cubeApi.sql(query, { mutexObj: this.mutexObj, mutexKey: 'sql' }),\n          cubeApi.load(query, { mutexObj: this.mutexObj, mutexKey: 'query' })\n        ]).then(([sqlQuery, resultSet]) => this.setState({\n          sqlQuery, resultSet, error: null, isLoading: false\n        }))\n          .catch(error => this.setState({\n            ...(resetResultSetOnChange ? { resultSet: null } : {}),\n            error,\n            isLoading: false\n          }));\n      } else {\n        cubeApi.load(query, { mutexObj: this.mutexObj, mutexKey: 'query' })\n          .then(resultSet => this.setState({ resultSet, error: null, isLoading: false }))\n          .catch(error => this.setState({\n            ...(resetResultSetOnChange ? { resultSet: null } : {}),\n            error,\n            isLoading: false\n          }));\n      }\n    }\n  }\n\n  loadQueries(queries) {\n    const cubeApi = this.cubeApi();\n    const { resetResultSetOnChange } = this.props;\n    this.setState({\n      isLoading: true,\n      ...(resetResultSetOnChange ? { resultSet: null } : {}),\n      error: null\n    });\n\n    const resultPromises = Promise.all(toPairs(queries).map(\n      ([name, query]) => cubeApi.load(query, { mutexObj: this.mutexObj, mutexKey: name }).then(r => [name, r])\n    ));\n\n    resultPromises\n      .then(resultSet => this.setState({\n        resultSet: fromPairs(resultSet),\n        error: null,\n        isLoading: false\n      }))\n      .catch(error => this.setState({\n        ...(resetResultSetOnChange ? { resultSet: null } : {}),\n        error,\n        isLoading: false\n      }));\n  }\n\n  render() {\n    const {\n      error, queries, resultSet, isLoading, sqlQuery\n    } = this.state;\n    const { render } = this.props;\n\n    const loadState = {\n      error: error ? new Error(error.response?.plainError || error.message || error.toString()) : null,\n      resultSet: queries ? (resultSet || {}) : resultSet,\n      loadingState: { isLoading },\n      sqlQuery\n    };\n\n    if (render) {\n      return render(loadState);\n    }\n\n    return null;\n  }\n}\n", "import React from 'react';\nimport QueryRenderer from './QueryRenderer.jsx';\n\nconst QueryRendererWithTotals = ({ query, ...restProps }) => (\n  <QueryRenderer\n    queries={{\n      totals: {\n        ...query,\n        dimensions: [],\n        timeDimensions: query.timeDimensions\n          ? query.timeDimensions.map(td => ({ ...td, granularity: null }))\n          : undefined\n      },\n      main: query\n    }}\n    {...restProps}\n  />\n);\n\nexport default QueryRendererWithTotals;\n", "export function removeEmpty(obj) {\n  if (typeof obj !== 'object') {\n    return obj;\n  }\n\n  return Object.fromEntries(\n    Object.entries(obj)\n      .filter(([, v]) => v != null)\n      .map(([k, v]) => {\n        if (Array.isArray(v)) {\n          return [k, v.map(removeEmpty)];\n        }\n\n        return [k, typeof v === 'object' ? removeEmpty(v) : v];\n      })\n  );\n}\n", "import React from 'react';\nimport { clone, equals, indexBy, pick, prop, uniq, uniqBy } from 'ramda';\nimport {\n  defaultHeuristics,\n  defaultOrder,\n  flattenFilters,\n  getQueryMembers,\n  isQueryPresent,\n  moveItemInArray,\n  movePivotItem,\n  validateQuery,\n  ResultSet,\n  removeEmptyQueryFields\n} from '@cubejs-client/core';\n\nimport QueryRenderer from './QueryRenderer.jsx';\nimport CubeContext from './CubeContext';\nimport { removeEmpty } from './utils';\n\nconst granularities = [\n  { name: undefined, title: 'w/o grouping' },\n  { name: 'second', title: 'Second' },\n  { name: 'minute', title: 'Minute' },\n  { name: 'hour', title: 'Hour' },\n  { name: 'day', title: 'Day' },\n  { name: 'week', title: 'Week' },\n  { name: 'month', title: 'Month' },\n  { name: 'quarter', title: 'Quarter' },\n  { name: 'year', title: 'Year' },\n];\n\nexport default class QueryBuilder extends React.Component {\n  static contextType = CubeContext;\n\n  static defaultProps = {\n    cubeApi: null,\n    stateChangeHeuristics: null,\n    disableHeuristics: false,\n    render: null,\n    wrapWithQueryRenderer: true,\n    defaultChartType: 'line',\n    defaultQuery: {},\n    initialVizState: null,\n    onVizStateChanged: null,\n\n    // deprecated\n    query: null,\n    setQuery: null,\n    vizState: null,\n    setVizState: null,\n  };\n\n  // This is an anti-pattern, only kept for backward compatibility\n  // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state\n  static getDerivedStateFromProps(props, state) {\n    if (props.query || props.vizState) {\n      const nextState = {\n        ...state,\n        ...(props.vizState || {}),\n      };\n\n      if (Array.isArray(props.query)) {\n        throw new Error('Array of queries is not supported.');\n      }\n\n      return {\n        ...nextState,\n        query: {\n          ...nextState.query,\n          ...(props.query || {}),\n        },\n      };\n    }\n    return null;\n  }\n\n  static resolveMember(type, { meta, query }) {\n    if (!meta) {\n      return [];\n    }\n\n    if (Array.isArray(query)) {\n      return query.reduce(\n        (memo, currentQuery) => memo.concat(\n          QueryBuilder.resolveMember(type, {\n            meta,\n            query: currentQuery,\n          })\n        ),\n        []\n      );\n    }\n\n    if (type === 'timeDimensions') {\n      return (query.timeDimensions || []).map((m, index) => ({\n        ...m,\n        dimension: {\n          ...meta.resolveMember(m.dimension, 'dimensions'),\n          granularities,\n        },\n        index,\n      }));\n    }\n\n    return (query[type] || []).map((m, index) => ({\n      index,\n      ...meta.resolveMember(m, type),\n    }));\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      query: props.defaultQuery || props.query,\n      chartType: props.defaultChartType,\n      validatedQuery: props.query, // deprecated, validatedQuery should not be set until after dry-run for safety\n      missingMembers: [],\n      // todo: rename to `isMetaReady`\n      isFetchingMeta: true,\n      dryRunResponse: null,\n      ...props.vizState, // deprecated\n      ...props.initialVizState,\n    };\n\n    this.mutexObj = {};\n    this.orderMembersOrderKeys = [];\n  }\n\n  async componentDidMount() {\n    this.prevContext = this.context;\n    await this.fetchMeta();\n  }\n\n  async componentDidUpdate(prevProps) {\n    const { schemaVersion, onSchemaChange } = this.props;\n    const { meta } = this.state;\n\n    if (this.prevContext?.cubeApi !== this.context?.cubeApi) {\n      this.prevContext = this.context;\n      await this.fetchMeta();\n    }\n\n    if (prevProps.schemaVersion !== schemaVersion) {\n      try {\n        const newMeta = await this.cubeApi().meta();\n        if (!equals(newMeta, meta) && typeof onSchemaChange === 'function') {\n          onSchemaChange({\n            schemaVersion,\n            refresh: async () => {\n              await this.fetchMeta();\n            },\n          });\n        }\n      } catch (error) {\n        // eslint-disable-next-line\n        this.setState({ metaError: error });\n      }\n    }\n  }\n\n  fetchMeta = async () => {\n    if (!this.cubeApi()) {\n      return;\n    }\n\n    let meta;\n    let metaError = null;\n    let richMetaError = null;\n    let metaErrorStack = null;\n\n    try {\n      this.setState({ isFetchingMeta: true });\n      meta = await this.cubeApi().meta();\n    } catch (error) {\n      metaError = error.response?.plainError || error;\n      richMetaError = error;\n      metaErrorStack = error.response?.stack?.replace(error.message || '', '') || '';\n    }\n\n    this.setState(\n      {\n        meta,\n        metaError: metaError ? new Error(metaError.message || metaError.toString()) : null,\n        richMetaError,\n        metaErrorStack,\n        isFetchingMeta: false,\n      },\n      () => {\n        // Run update query to force viz state update\n        // This will catch any new missing members, and also validate the query against the new meta\n        this.updateQuery({});\n      }\n    );\n  };\n\n  cubeApi() {\n    const { cubeApi } = this.props;\n    // eslint-disable-next-line react/destructuring-assignment\n    return cubeApi || (this.context && this.context.cubeApi);\n  }\n\n  getMissingMembers(query, meta) {\n    if (!meta) {\n      return [];\n    }\n\n    return getQueryMembers(query)\n      .map((member) => {\n        const resolvedMember = meta.resolveMember(member, ['measures', 'dimensions', 'segments']);\n        if (resolvedMember.error) {\n          return member;\n        }\n        return false;\n      })\n      .filter(Boolean);\n  }\n\n  isQueryPresent() {\n    const { query } = this.state;\n    return QueryRenderer.isQueryPresent(query);\n  }\n\n  prepareRenderProps(queryRendererProps) {\n    const getName = (member) => member.name;\n\n    const toTimeDimension = (member) => {\n      const rangeSelection = member.compareDateRange\n        ? { compareDateRange: member.compareDateRange }\n        : { dateRange: member.dateRange };\n\n      return removeEmpty({\n        dimension: member.dimension.name,\n        granularity: member.granularity,\n        ...rangeSelection,\n      });\n    };\n\n    const toFilter = (member) => ({\n      member: member.member?.name || member.dimension?.name,\n      operator: member.operator,\n      ...(['set', 'notSet'].includes(member.operator) ? {} : { values: member.values }),\n    });\n\n    const updateMethods = (memberType, toQuery = getName) => ({\n      add: (member) => {\n        const { query } = this.state;\n        this.updateQuery({\n          [memberType]: (query[memberType] || []).concat(toQuery(member)),\n        });\n      },\n      remove: (member) => {\n        const { query } = this.state;\n\n        return this.updateQuery({\n          [memberType]: (query[memberType] || []).filter((_, index) => index !== member.index),\n        });\n      },\n      update: (member, updateWith) => {\n        const { query } = this.state;\n        const members = (query[memberType] || []).concat([]);\n        members.splice(member.index, 1, toQuery(updateWith));\n        return this.updateQuery({\n          [memberType]: members,\n        });\n      },\n    });\n\n    const {\n      meta,\n      metaError,\n      richMetaError,\n      query,\n      queryError,\n      chartType,\n      pivotConfig,\n      validatedQuery,\n      missingMembers,\n      isFetchingMeta,\n      dryRunResponse,\n      metaErrorStack\n    } = this.state;\n\n    const flatFilters = uniqBy((filter) => `${prop('member', filter)}${prop('operator', filter)}`,\n      flattenFilters((meta && query.filters) || []).map((filter) => ({\n        ...filter,\n        member: filter.member || filter.dimension,\n      })));\n\n    const filters = flatFilters.map((m, i) => ({\n      ...m,\n      dimension: meta.resolveMember(m.member || m.dimension, ['dimensions', 'measures']),\n      operators: meta.filterOperatorsForMember(m.member || m.dimension, ['dimensions', 'measures']),\n      index: i,\n    }));\n\n    const measures = QueryBuilder.resolveMember('measures', this.state);\n    const dimensions = QueryBuilder.resolveMember('dimensions', this.state);\n    const timeDimensions = QueryBuilder.resolveMember('timeDimensions', this.state);\n    const segments = ((meta && query.segments) || []).map((m, i) => ({\n      index: i,\n      ...meta.resolveMember(m, 'segments'),\n    }));\n\n    let availableMeasures = [];\n    let availableDimensions = [];\n    let availableSegments = [];\n    let availableFilterMembers = [];\n\n    const availableMembers = meta?.membersGroupedByCube() || {\n      measures: [],\n      dimensions: [],\n      segments: [],\n      timeDimensions: [],\n    };\n\n    if (meta) {\n      availableMeasures = meta.membersForQuery(query, 'measures');\n      availableDimensions = meta.membersForQuery(query, 'dimensions');\n      availableSegments = meta.membersForQuery(query, 'segments');\n\n      const indexedMeasures = indexBy(prop('cubeName'), availableMembers.measures);\n      const indexedDimensions = indexBy(prop('cubeName'), availableMembers.dimensions);\n      const cubeNames = uniq([...Object.keys(indexedMeasures), ...Object.keys(indexedDimensions)]).sort();\n\n      availableFilterMembers = cubeNames.map((name) => {\n        const cube = indexedMeasures[name] || indexedDimensions[name];\n\n        return {\n          ...cube,\n          members: [\n            ...indexedMeasures[name]?.members,\n            ...indexedDimensions[name]?.members\n          ].sort((a, b) => (a.shortTitle > b.shortTitle ? 1 : -1)),\n        };\n      });\n    }\n\n    const activeOrder = Array.isArray(query.order) ? Object.fromEntries(query.order) : query.order;\n    const members = [\n      ...measures,\n      ...dimensions,\n      ...timeDimensions.map(({ dimension }) => dimension)\n    ];\n\n    let orderMembers = uniqBy(prop('id'), [\n      // uniqBy prefers first, so these will only be added if not already in the query\n      ...members.map(({ name, title }) => ({ id: name, title, order: activeOrder?.[name] || 'none' })),\n    ]);\n\n    if (this.orderMembersOrderKeys.length !== orderMembers.length) {\n      this.orderMembersOrderKeys = orderMembers.map(({ id }) => id);\n    }\n\n    if (this.orderMembersOrderKeys.length) {\n      // Preserve order until the members change or manually re-ordered\n      // This is needed so that when an order member becomes active, it doesn't jump to the top of the list\n      orderMembers = (this.orderMembersOrderKeys || [])\n        .map((id) => orderMembers.find((member) => member.id === id))\n        .filter(Boolean);\n    }\n\n    return {\n      meta,\n      metaError,\n      richMetaError,\n      metaErrorStack,\n      query,\n      error: queryError, // Match same name as QueryRenderer prop\n      validatedQuery,\n      isQueryPresent: this.isQueryPresent(),\n      chartType,\n      measures,\n      dimensions,\n      timeDimensions,\n      segments,\n      filters,\n      orderMembers,\n      availableMeasures,\n      availableDimensions,\n      availableTimeDimensions: availableDimensions.filter((m) => m.type === 'time'),\n      availableSegments,\n      availableMembers,\n      availableFilterMembers,\n      updateQuery: (queryUpdate) => this.updateQuery(queryUpdate),\n      updateMeasures: updateMethods('measures'),\n      updateDimensions: updateMethods('dimensions'),\n      updateSegments: updateMethods('segments'),\n      updateTimeDimensions: updateMethods('timeDimensions', toTimeDimension),\n      updateFilters: updateMethods('filters', toFilter),\n      updateChartType: (newChartType) => this.updateVizState({ chartType: newChartType }),\n      updateOrder: {\n        set: (memberId, newOrder = 'asc') => {\n          this.updateQuery({\n            order: orderMembers\n              .map((orderMember) => ({\n                ...orderMember,\n                order: orderMember.id === memberId ? newOrder : orderMember.order,\n              }))\n              .reduce((acc, { id, order }) => (order !== 'none' ? [...acc, [id, order]] : acc), []),\n          });\n        },\n        update: (order) => {\n          this.updateQuery({\n            order,\n          });\n        },\n        reorder: (sourceIndex, destinationIndex) => {\n          if (sourceIndex == null || destinationIndex == null) {\n            return;\n          }\n\n          const nextArray = moveItemInArray(orderMembers, sourceIndex, destinationIndex);\n          this.orderMembersOrderKeys = nextArray.map(({ id }) => id);\n\n          this.updateQuery({\n            order: nextArray.reduce((acc, { id, order }) => (order !== 'none' ? [...acc, [id, order]] : acc), []),\n          });\n        },\n      },\n      pivotConfig,\n      updatePivotConfig: {\n        moveItem: ({ sourceIndex, destinationIndex, sourceAxis, destinationAxis }) => {\n          this.updateVizState({\n            pivotConfig: movePivotItem(pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis),\n          });\n        },\n        update: (config) => {\n          const { limit } = config;\n\n          this.updateVizState({\n            pivotConfig: {\n              ...pivotConfig,\n              ...config,\n            },\n            ...(limit ? { query: { ...query, limit } } : null),\n          });\n        },\n      },\n      missingMembers,\n      refresh: this.fetchMeta,\n      isFetchingMeta,\n      dryRunResponse,\n      ...queryRendererProps,\n    };\n  }\n\n  updateQuery(queryUpdate) {\n    const { query } = this.state;\n\n    this.updateVizState({\n      query: removeEmptyQueryFields({\n        ...query,\n        ...queryUpdate,\n      }),\n    });\n  }\n\n  async updateVizState(state) {\n    const { setQuery, setVizState } = this.props;\n    const { query: stateQuery, pivotConfig: statePivotConfig, chartType, meta } = this.state;\n\n    const finalState = this.applyStateChangeHeuristics(state);\n    if (!finalState.query) {\n      finalState.query = { ...stateQuery };\n    }\n\n    let vizStateSent = null;\n    const handleVizStateChange = (currentState) => {\n      const { onVizStateChanged } = this.props;\n      if (onVizStateChanged) {\n        const newVizState = pick(['chartType', 'pivotConfig', 'query'], currentState);\n        // Don't run callbacks more than once unless the viz state has changed since last time\n        if (!vizStateSent || !equals(vizStateSent, newVizState)) {\n          onVizStateChanged(newVizState);\n          // use clone to make sure we don't save object references\n          vizStateSent = clone(newVizState);\n        }\n      }\n    };\n\n    // deprecated, setters replaced by onVizStateChanged\n    const runSetters = (currentState) => {\n      if (setVizState) {\n        setVizState(pick(['chartType', 'pivotConfig', 'query'], currentState));\n      }\n      if (currentState.query && setQuery) {\n        setQuery(currentState.query);\n      }\n    };\n\n    if (finalState.shouldApplyHeuristicOrder) {\n      finalState.query.order = defaultOrder(finalState.query);\n    }\n\n    finalState.pivotConfig = ResultSet.getNormalizedPivotConfig(\n      finalState.query,\n      finalState.pivotConfig !== undefined ? finalState.pivotConfig : statePivotConfig\n    );\n\n    finalState.missingMembers = this.getMissingMembers(finalState.query, meta);\n    finalState.chartType = finalState.chartType || state.chartType || chartType;\n\n    // deprecated\n    runSetters({\n      ...state,\n      query: finalState.query,\n    });\n\n    // Update optimistically so that UI does not stutter\n    this.setState({\n      ...finalState,\n      queryError: null,\n    });\n\n    handleVizStateChange(finalState);\n\n    const shouldFetchDryRun = !equals(\n      pick(['measures', 'dimensions', 'timeDimensions'], stateQuery),\n      pick(['measures', 'dimensions', 'timeDimensions'], finalState.query)\n    );\n\n    if (shouldFetchDryRun && isQueryPresent(finalState.query) && finalState.missingMembers.length === 0) {\n      try {\n        const response = await this.cubeApi().dryRun(finalState.query, {\n          mutexObj: this.mutexObj,\n        });\n\n        if (finalState.shouldApplyHeuristicOrder) {\n          finalState.query.order = (response.queryOrder || []).reduce((memo, current) => ({ ...memo, ...current }), {});\n        }\n\n        finalState.pivotConfig = ResultSet.getNormalizedPivotConfig(response.pivotQuery, finalState.pivotConfig);\n        finalState.validatedQuery = this.validatedQuery(finalState);\n        finalState.dryRunResponse = response;\n\n        // deprecated\n        if (isQueryPresent(stateQuery)) {\n          runSetters({\n            ...this.state,\n            ...finalState,\n          });\n        }\n      } catch (error) {\n        this.setState({\n          queryError: new Error(error.response?.plainError || error.message),\n          richQueryError: new Error(error.message || error.toString())\n        });\n      }\n    }\n\n    this.setState(finalState, () => handleVizStateChange(this.state));\n  }\n\n  validatedQuery(state) {\n    const { query } = state || this.state;\n\n    return validateQuery(query);\n  }\n\n  defaultHeuristics(newState) {\n    const { query, sessionGranularity, meta } = this.state;\n\n    return defaultHeuristics(newState, query, {\n      meta,\n      sessionGranularity: sessionGranularity || 'day',\n    });\n  }\n\n  applyStateChangeHeuristics(newState) {\n    const { stateChangeHeuristics, disableHeuristics } = this.props;\n    if (disableHeuristics) {\n      return newState;\n    }\n    return (stateChangeHeuristics && stateChangeHeuristics(this.state, newState)) || this.defaultHeuristics(newState);\n  }\n\n  render() {\n    const { query } = this.state;\n    const { cubeApi, render, wrapWithQueryRenderer } = this.props;\n\n    if (wrapWithQueryRenderer) {\n      return (\n        <QueryRenderer\n          query={query}\n          cubeApi={cubeApi}\n          resetResultSetOnChange={false}\n          render={(queryRendererProps) => {\n            if (render) {\n              return render(this.prepareRenderProps(queryRendererProps));\n            }\n            return null;\n          }}\n        />\n      );\n    } else {\n      if (render) {\n        return render(this.prepareRenderProps());\n      }\n      return null;\n    }\n  }\n}\n", "import React from 'react';\nimport CubeContext from './CubeContext';\n\nexport default function CubeProvider({ cubeApi, children, options = {} }) {\n  return (\n    <CubeContext.Provider value={{\n      cubeApi,\n      options\n    }}\n    >\n      {children}\n    </CubeContext.Provider>\n  );\n}\n", "import { useRef } from 'react';\nimport { equals } from 'ramda';\n\nexport default function useDeepCompareMemoize(value) {\n  const ref = useRef([]);\n\n  if (!equals(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n", "import { useEffect, useRef } from 'react';\n\nexport function useIsMounted() {\n  const isMounted = useRef(false);\n\n  useEffect(() => {\n    isMounted.current = true;\n\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return () => isMounted.current;\n}\n", "import { useContext, useEffect, useState, useRef } from 'react';\nimport { isQueryPresent } from '@cubejs-client/core';\n\nimport CubeContext from '../CubeContext';\nimport useDeepCompareMemoize from './deep-compare-memoize';\nimport { useIsMounted } from './is-mounted';\n\nexport function useCubeFetch(method, options = {}) {\n  const isMounted = useIsMounted();\n  const context = useContext(CubeContext);\n  const mutexRef = useRef({});\n\n  const [response, setResponse] = useState({\n    isLoading: false,\n    response: null,\n  });\n  const [error, setError] = useState(null);\n\n  const { skip = false } = options;\n\n  async function load(loadOptions = {}, ignoreSkip = false) {\n    const cubeApi = options.cubeApi || context?.cubeApi;\n    const query = loadOptions.query || options.query;\n\n    const queryCondition = method === 'meta' ? true : query && isQueryPresent(query);\n\n    if (cubeApi && (ignoreSkip || !skip) && queryCondition) {\n      setError(null);\n      setResponse({\n        isLoading: true,\n        response: null,\n      });\n\n      const coreOptions = {\n        mutexObj: mutexRef.current,\n        mutexKey: method,\n      };\n      const args = method === 'meta' ? [coreOptions] : [query, coreOptions];\n\n      try {\n        const response = await cubeApi[method](...args);\n\n        if (isMounted()) {\n          setResponse({\n            response,\n            isLoading: false,\n          });\n        }\n      } catch (error) {\n        if (isMounted()) {\n          setError(error);\n          setResponse({\n            isLoading: false,\n            response: null,\n          });\n        }\n      }\n    }\n  }\n\n  useEffect(() => {\n    load();\n  }, useDeepCompareMemoize([Object.keys(options.query?.order || {}), options, context]));\n\n  return {\n    ...response,\n    error,\n    refetch: (options) => load(options, true),\n  };\n}\n", "import { useCubeFetch } from './cube-fetch';\n\nexport function useCubeSql(query, options = {}) {\n  return useCubeFetch('sql', {\n    ...options,\n    query\n  });\n}\n", "import { useCubeFetch } from './cube-fetch';\n\nexport function useDryRun(query, options = {}) {\n  return useCubeFetch('dryRun', {\n    ...options,\n    query,\n  });\n}\n", "import { useCubeFetch } from './cube-fetch';\n\nexport function useLazyDryRun(query, options = {}) {\n  const { refetch, ...result } = useCubeFetch('dryRun', {\n    ...options,\n    query,\n    skip: true\n  });\n\n  return [refetch, result];\n}\n", "import { useContext, useEffect, useState, useRef } from 'react';\nimport { isQueryPresent, areQueriesEqual } from '@cubejs-client/core';\n\nimport CubeContext from '../CubeContext';\nimport useDeepCompareMemoize from './deep-compare-memoize';\nimport { useIsMounted } from './is-mounted';\n\nexport function useCubeQuery(query, options = {}) {\n  const mutexRef = useRef({});\n  const isMounted = useIsMounted();\n  const [currentQuery, setCurrentQuery] = useState(null);\n  const [isLoading, setLoading] = useState(false);\n  const [resultSet, setResultSet] = useState(null);\n  const [progress, setProgress] = useState(null);\n  const [error, setError] = useState(null);\n  const context = useContext(CubeContext);\n\n  let subscribeRequest = null;\n\n  const progressCallback = ({ progressResponse }) => setProgress(progressResponse);\n\n  async function fetch() {\n    const { resetResultSetOnChange } = options;\n    const cubeApi = options.cubeApi || context?.cubeApi;\n\n    if (!cubeApi) {\n      throw new Error('Cube API client is not provided');\n    }\n\n    if (resetResultSetOnChange) {\n      setResultSet(null);\n    }\n\n    setError(null);\n    setLoading(true);\n    \n    try {\n      const response = await cubeApi.load(query, {\n        mutexObj: mutexRef.current,\n        mutexKey: 'query',\n        progressCallback,\n        castNumerics: Boolean(typeof options.castNumerics === 'boolean' ? options.castNumerics : context?.options?.castNumerics)\n      });\n\n      if (isMounted()) {\n        setResultSet(response);\n        setProgress(null);\n      }\n    } catch (error) {\n      if (isMounted()) {\n        setError(error);\n        setResultSet(null);\n        setProgress(null);\n      }\n    }\n\n    if (isMounted()) {\n      setLoading(false);\n    }\n  }\n\n  useEffect(() => {\n    const { skip = false, resetResultSetOnChange } = options;\n\n    const cubeApi = options.cubeApi || context?.cubeApi;\n\n    if (!cubeApi) {\n      throw new Error('Cube API client is not provided');\n    }\n\n    async function loadQuery() {\n      if (!skip && isQueryPresent(query)) {\n        if (!areQueriesEqual(currentQuery, query)) {\n          if (resetResultSetOnChange == null || resetResultSetOnChange) {\n            setResultSet(null);\n          }\n          setCurrentQuery(query);\n        }\n\n        setError(null);\n        setLoading(true);\n\n        try {\n          if (subscribeRequest) {\n            await subscribeRequest.unsubscribe();\n            subscribeRequest = null;\n          }\n\n          if (options.subscribe) {\n            subscribeRequest = cubeApi.subscribe(\n              query,\n              {\n                mutexObj: mutexRef.current,\n                mutexKey: 'query',\n                progressCallback,\n              },\n              (e, result) => {\n                if (isMounted()) {\n                  if (e) {\n                    setError(e);\n                  } else {\n                    setResultSet(result);\n                  }\n                  setLoading(false);\n                  setProgress(null);\n                }\n              }\n            );\n          } else {\n            await fetch();\n          }\n        } catch (e) {\n          if (isMounted()) {\n            setError(e);\n            setResultSet(null);\n            setLoading(false);\n            setProgress(null);\n          }\n        }\n      }\n    }\n\n    loadQuery();\n\n    return () => {\n      if (subscribeRequest) {\n        subscribeRequest.unsubscribe();\n        subscribeRequest = null;\n      }\n    };\n  }, useDeepCompareMemoize([query, Object.keys((query && query.order) || {}), options, context]));\n\n  return {\n    isLoading,\n    resultSet,\n    error,\n    progress,\n    previousQuery: currentQuery,\n    refetch: fetch\n  };\n}\n", "import { useCubeFetch } from './cube-fetch';\n\nexport function useCubeMeta(options = {}) {\n  return useCubeFetch('meta', options);\n}\n"],
  "mappings": "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",
  "names": ["createContext", "QueryRenderer", "React", "Component", "isQueryPresent", "query", "constructor", "props", "state", "mutexObj", "componentDidMount", "queries", "load", "loadQueries", "shouldComponentUpdate", "nextProps", "nextState", "render", "cubeApi", "loadSql", "updateOnlyOnStateChange", "equals", "componentDidUpdate", "prevProps", "context", "resetResultSetOnChange", "setState", "isLoading", "error", "sqlQuery", "resultSet", "sql", "mutexKey", "then", "catch", "Promise", "all", "resultPromises", "toPairs", "map", "name", "r", "fromPairs", "loadState", "Error", "response", "plainError", "message", "toString", "loadingState", "contextType", "CubeContext", "defaultProps", "QueryRendererWithTotals", "restProps", "totals", "dimensions", "timeDimensions", "td", "granularity", "undefined", "main", "removeEmpty", "obj", "Object", "fromEntries", "entries", "filter", "v", "k", "Array", "isArray", "granularities", "title", "QueryBuilder", "fetchMeta", "meta", "metaError", "richMetaError", "metaErrorStack", "isFetchingMeta", "stack", "replace", "updateQuery", "defaultQuery", "chartType", "defaultChartType", "validatedQuery", "missingMembers", "dryRunResponse", "vizState", "initialVizState", "orderMembersOrderKeys", "getDerivedStateFromProps", "resolveMember", "type", "reduce", "memo", "currentQuery", "concat", "m", "index", "dimension", "prevContext", "schemaVersion", "onSchemaChange", "newMeta", "refresh", "getMissingMembers", "getQueryMembers", "member", "resolvedMember", "Boolean", "prepareRenderProps", "queryRendererProps", "getName", "toTimeDimension", "rangeSelection", "compareDateRange", "dateRange", "toFilter", "operator", "includes", "values", "updateMethods", "memberType", "toQuery", "add", "remove", "_", "update", "updateWith", "members", "splice", "queryError", "pivotConfig", "flatFilters", "uniqBy", "prop", "flattenFilters", "filters", "i", "operators", "filterOperatorsForMember", "measures", "segments", "availableMeasures", "availableDimensions", "availableSegments", "availableFilterMembers", "availableMembers", "membersGroupedByCube", "membersForQuery", "indexedMeasures", "indexBy", "indexedDimensions", "cubeNames", "uniq", "keys", "sort", "cube", "a", "b", "shortTitle", "activeOrder", "order", "orderMembers", "id", "length", "find", "availableTimeDimensions", "queryUpdate", "updateMeasures", "updateDimensions", "updateSegments", "updateTimeDimensions", "updateFilters", "updateChartType", "newChartType", "updateVizState", "updateOrder", "set", "memberId", "newOrder", "orderMember", "acc", "reorder", "sourceIndex", "destinationIndex", "nextArray", "moveItemInArray", "updatePivotConfig", "moveItem", "sourceAxis", "destinationAxis", "movePivotItem", "config", "limit", "removeEmptyQueryFields", "setQuery", "setVizState", "stateQuery", "statePivotConfig", "finalState", "applyStateChangeHeuristics", "vizStateSent", "handleVizStateChange", "currentState", "onVizStateChanged", "newVizState", "pick", "clone", "runSetters", "shouldApplyHeuristicOrder", "defaultOrder", "ResultSet", "getNormalizedPivotConfig", "shouldFetchDryRun", "dryRun", "queryOrder", "current", "pivotQuery", "richQueryError", "validateQuery", "defaultHeuristics", "newState", "sessionGranularity", "stateChangeHeuristics", "disableHeuristics", "wrapWithQueryRenderer", "CubeProvider", "children", "options", "useDeepCompareMemoize", "value", "ref", "useRef", "useIsMounted", "isMounted", "useEffect", "useCubeFetch", "method", "useContext", "mutexRef", "setResponse", "useState", "setError", "skip", "loadOptions", "ignoreSkip", "queryCondition", "coreOptions", "args", "refetch", "useCubeSql", "useDryRun", "useLazyDryRun", "result", "useCubeQuery", "setCurrentQuery", "setLoading", "setResultSet", "progress", "setProgress", "subscribeRequest", "progressCallback", "progressResponse", "fetch", "castNumerics", "loadQuery", "areQueriesEqual", "unsubscribe", "subscribe", "e", "previousQuery", "useCubeMeta"]
}
